"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassParser = void 0;
var Models_1 = require("./Models");
var ScopeHelper_1 = require("./ScopeHelper");
var RegExHelper_1 = require("./RegExHelper");
var MethodParser_1 = require("./MethodParser");
var PropertyParser_1 = require("./PropertyParser");
var InterfaceParser_1 = require("./InterfaceParser");
var AttributeParser_1 = require("./AttributeParser");
var ClassParser = /** @class */ (function () {
    function ClassParser(typeParser, enumParser, fieldParser) {
        this.typeParser = typeParser;
        this.enumParser = enumParser;
        this.fieldParser = fieldParser;
        this.scopeHelper = new ScopeHelper_1.ScopeHelper();
        this.regexHelper = new RegExHelper_1.RegExHelper();
        this.propertyParser = new PropertyParser_1.PropertyParser();
        this.attributeParser = new AttributeParser_1.AttributeParser();
        this.interfaceParser = new InterfaceParser_1.InterfaceParser(typeParser);
        this.methodParser = new MethodParser_1.MethodParser(typeParser);
    }
    ClassParser.prototype.parseClasses = function (content) {
        var classes = new Array();
        var scopes = this.scopeHelper.getCurlyScopes(content);
        for (var _i = 0, scopes_1 = scopes; _i < scopes_1.length; _i++) {
            var scope = scopes_1[_i];
            var statements = this.scopeHelper.getStatements(scope.prefix);
            for (var _a = 0, statements_1 = statements; _a < statements_1.length; _a++) {
                var statement = statements_1[_a];
                var matches = this.regexHelper.getMatches(statement, new RegExp("^" + this.regexHelper.getClassRegex() + "$", "g"));
                for (var _b = 0, matches_1 = matches; _b < matches_1.length; _b++) {
                    var match = matches_1[_b];
                    try {
                        var attributes = match[0];
                        var modifiers = match[1] || "";
                        var name = match[2];
                        var genericParameters = match[3];
                        var inheritance = match[4];
                        var classObject = new Models_1.CSharpClass(name);
                        classObject.isPublic = modifiers.indexOf("public") > -1;
                        classObject.isStatic = modifiers.indexOf("static") > -1;
                        classObject.attributes = this.attributeParser.parseAttributes(attributes);
                        classObject.innerScopeText = scope.content;
                        classObject.genericParameters = this.typeParser.parseTypesFromGenericParameters(genericParameters);
                        classObject.inheritsFrom = this.typeParser.parseTypesFromGenericParameters(inheritance);
                        var fields = this.fieldParser.parseFields(scope.content);
                        for (var _c = 0, fields_1 = fields; _c < fields_1.length; _c++) {
                            var field = fields_1[_c];
                            field.parent = classObject;
                            classObject.fields.push(field);
                        }
                        var properties = this.propertyParser.parseProperties(scope.content);
                        for (var _d = 0, properties_1 = properties; _d < properties_1.length; _d++) {
                            var property = properties_1[_d];
                            property.parent = classObject;
                            classObject.properties.push(property);
                        }
                        var enums = this.enumParser.parseEnums(scope.content);
                        for (var _e = 0, enums_1 = enums; _e < enums_1.length; _e++) {
                            var enumObject = enums_1[_e];
                            enumObject.parent = classObject;
                            classObject.enums.push(enumObject);
                        }
                        var methods = this.methodParser.parseMethods(scope.content, classObject);
                        for (var _f = 0, methods_1 = methods; _f < methods_1.length; _f++) {
                            var method = methods_1[_f];
                            method.parent = classObject;
                            classObject.methods.push(method);
                        }
                        var subClasses = this.parseClasses(scope.content);
                        for (var _g = 0, subClasses_1 = subClasses; _g < subClasses_1.length; _g++) {
                            var subClass = subClasses_1[_g];
                            subClass.parent = classObject;
                            classObject.classes.push(subClass);
                        }
                        var interfaces = this.interfaceParser.parseInterfaces(scope.content);
                        for (var _h = 0, interfaces_1 = interfaces; _h < interfaces_1.length; _h++) {
                            var interfaceObject = interfaces_1[_h];
                            classObject.interfaces.push(interfaceObject);
                        }
                        classObject.constructors = classObject
                            .methods
                            .filter(function (x) { return x.isConstructor; });
                        classObject.methods = classObject
                            .methods
                            .filter(function (x) { return !x.isConstructor; });
                        classes.push(classObject);
                    }
                    catch (ex) {
                        console.error("Skipping class due to parsing error.", statement, ex);
                        debugger;
                    }
                }
            }
        }
        return classes;
    };
    return ClassParser;
}());
exports.ClassParser = ClassParser;
//# sourceMappingURL=ClassParser.js.map