"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumParser = void 0;
var Models_1 = require("./Models");
var ScopeHelper_1 = require("./ScopeHelper");
var RegExHelper_1 = require("./RegExHelper");
var AttributeParser_1 = require("./AttributeParser");
var EnumParser = /** @class */ (function () {
    function EnumParser(typeParser) {
        this.typeParser = typeParser;
        this.scopeHelper = new ScopeHelper_1.ScopeHelper();
        this.regexHelper = new RegExHelper_1.RegExHelper();
        this.attributeParser = new AttributeParser_1.AttributeParser();
    }
    EnumParser.prototype.parseEnums = function (content) {
        var enums = new Array();
        var scopes = this.scopeHelper.getCurlyScopes(content);
        for (var _i = 0, scopes_1 = scopes; _i < scopes_1.length; _i++) {
            var scope = scopes_1[_i];
            var statements = this.scopeHelper.getStatements(scope.prefix);
            for (var _a = 0, statements_1 = statements; _a < statements_1.length; _a++) {
                var statement = statements_1[_a];
                var matches = this.regexHelper.getMatches(statement, new RegExp("^" + this.regexHelper.getEnumRegex(false, true, true, true, true) + "$", "g"));
                for (var _b = 0, matches_1 = matches; _b < matches_1.length; _b++) {
                    var match = matches_1[_b];
                    try {
                        var attributes = match[0];
                        var modifiers = match[1] || "";
                        var name = match[2];
                        var inheritance = match[3];
                        var enumObject = new Models_1.CSharpEnum(name);
                        enumObject.isPublic = modifiers.indexOf("public") > -1;
                        enumObject.attributes = this.attributeParser.parseAttributes(attributes);
                        enumObject.options = this.parseEnumOptions(scope.content);
                        enumObject.inheritsFrom = this.typeParser.parseType(inheritance);
                        enums.push(enumObject);
                    }
                    catch (ex) {
                        console.error("Skipping enum due to parsing error.", statement, ex);
                        debugger;
                    }
                }
            }
        }
        return enums;
    };
    EnumParser.prototype.parseEnumOptions = function (content) {
        var result = new Array();
        var nextValue = 0;
        var optionSplits = this.scopeHelper.getScopedList(",", content);
        for (var _i = 0, optionSplits_1 = optionSplits; _i < optionSplits_1.length; _i++) {
            var optionSplit = optionSplits_1[_i];
            var matches = this.regexHelper.getMatches(optionSplit, new RegExp("^" + this.regexHelper.getEnumOptionRegex(false, true, true, true) + "$", "g"));
            for (var _a = 0, matches_2 = matches; _a < matches_2.length; _a++) {
                var match = matches_2[_a];
                var attributes = match[0];
                var name = match[1];
                var value = match[2];
                var option = new Models_1.CSharpEnumOption(name);
                option.attributes = this.attributeParser.parseAttributes(attributes);
                if (value) {
                    option.value = parseInt(value);
                    nextValue = option.value + 1;
                }
                else {
                    option.value = nextValue;
                    nextValue++;
                }
                result.push(option);
            }
        }
        return result;
    };
    return EnumParser;
}());
exports.EnumParser = EnumParser;
//# sourceMappingURL=EnumParser.js.map