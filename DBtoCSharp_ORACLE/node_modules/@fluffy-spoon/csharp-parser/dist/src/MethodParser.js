"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodParser = void 0;
var Models_1 = require("./Models");
var ScopeHelper_1 = require("./ScopeHelper");
var RegExHelper_1 = require("./RegExHelper");
var AttributeParser_1 = require("./AttributeParser");
var LiteralParser_1 = require("./LiteralParser");
var MethodParser = /** @class */ (function () {
    function MethodParser(typeParser) {
        this.typeParser = typeParser;
        this.scopeHelper = new ScopeHelper_1.ScopeHelper();
        this.regexHelper = new RegExHelper_1.RegExHelper();
        this.attributeParser = new AttributeParser_1.AttributeParser();
        this.literalParser = new LiteralParser_1.LiteralParser();
    }
    MethodParser.prototype.parseMethods = function (content, parent) {
        var methods = new Array();
        var scopes = this.scopeHelper.getCurlyScopes(content);
        for (var _i = 0, scopes_1 = scopes; _i < scopes_1.length; _i++) {
            var scope = scopes_1[_i];
            var statements = this.scopeHelper.getStatements(scope.prefix);
            for (var _a = 0, statements_1 = statements; _a < statements_1.length; _a++) {
                var statement = statements_1[_a];
                var matches = this.regexHelper.getMatches(statement, new RegExp("^" + this.regexHelper.getMethodRegex(false, true, true, true, true, true, true, true) + "$", "g"));
                for (var _b = 0, matches_1 = matches; _b < matches_1.length; _b++) {
                    var match = matches_1[_b];
                    try {
                        var attributes = match[0];
                        var modifiers = match[1] || "";
                        var returnType = match[2];
                        var name = match[3];
                        var genericParameters = match[4];
                        var parameters = match[5];
                        var openingType = match[6];
                        var catchNoReturnType = this.regexHelper.getMatches(returnType, new RegExp("^" + this.regexHelper.getModifierRegex(true) + "$", "g"));
                        if (catchNoReturnType.length > 0 && catchNoReturnType[0].length > 0) {
                            modifiers += (modifiers ? " " : "") + catchNoReturnType[0][0];
                            returnType = "";
                        }
                        var method = new Models_1.CSharpMethod(name);
                        method.attributes = this.attributeParser.parseAttributes(attributes);
                        method.genericParameters = this.typeParser.parseTypesFromGenericParameters(genericParameters);
                        method.returnType = this.typeParser.parseType(returnType);
                        method.parameters = this.parseMethodParameters(parameters);
                        method.innerScopeText = scope.content;
                        method.parent = parent;
                        if (parent instanceof Models_1.CSharpClass && parent.name === method.name) {
                            method.isConstructor = true;
                            method.isVirtual = false;
                        }
                        else {
                            method.isVirtual = modifiers.indexOf("virtual") > -1;
                            method.isConstructor = false;
                        }
                        method.isPublic = modifiers.indexOf("public") > -1;
                        method.isStatic = modifiers.indexOf("static") > -1;
                        method.isBodyless = openingType === ";";
                        methods.push(method);
                    }
                    catch (ex) {
                        console.error("Skipping method due to parsing error.", statement, ex);
                        debugger;
                    }
                }
            }
        }
        return methods;
    };
    MethodParser.prototype.parseMethodParameters = function (content) {
        var result = new Array();
        var attributeSplits = this.scopeHelper.getScopedList(",", content);
        for (var _i = 0, attributeSplits_1 = attributeSplits; _i < attributeSplits_1.length; _i++) {
            var attributeSplit = attributeSplits_1[_i];
            var matches = this.regexHelper.getMatches(attributeSplit, new RegExp("^" + this.regexHelper.getMethodParameterRegex(false, true, true, true, true, true) + "$", "g"));
            if (matches.length > 1) {
                throw new Error("Method parameter split failed.");
            }
            try {
                result.push(this.parseMethodParameter(matches[0]));
            }
            catch (ex) {
                console.error("Skipping method parameter due to parsing error.", matches[0], ex);
                debugger;
            }
        }
        return result;
    };
    MethodParser.prototype.parseMethodParameter = function (match) {
        return {
            type: this.typeParser.parseType(match[2]),
            name: match[3],
            isVariadicContainer: !!match[1],
            attributes: this.attributeParser.parseAttributes(match[0]),
            defaultValue: this.literalParser.parseLiteral(match[4])
        };
    };
    return MethodParser;
}());
exports.MethodParser = MethodParser;
//# sourceMappingURL=MethodParser.js.map